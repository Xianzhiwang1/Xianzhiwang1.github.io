[
  {
    "objectID": "projects/project-02/main.html",
    "href": "projects/project-02/main.html",
    "title": "Project-02 Email without leaving the comfort of one’s terminal using Mutt",
    "section": "",
    "text": "Project-02 Email without leaving the comfort of one’s terminal using Mutt\nA quick and easy guide to use Mutt as your email client. Long story short, if we just want to use mutt with, say, our personal gmail account, then we could just open up a browser, go to our google account, and create a thing called app password, then go to github and install mutt-wizard, follow the instructions there, and it works pretty much out of the box. (Well, assuming one is familiar with the command line…) However, if you happen to have school/work gmail account that disables the app password feature, then you need to go thru some extra steps, and let me tell you how I went through these steps (tried and worked for me in April 2024).\nEssentially, one could follow the guidence outlined in this article, but the problem is that as in April 2024, the oauth2 access token will expire in one hour, and somehow the script mutt_oauth2.py does not get back a refresh token from the Google API, so if we stick with this script, after one hour, the access token expires, then we need to go thru the authentication process again, meaning: 1. copy paste a url from command line to a browser, 1. login to google account and authorize your own API to access your own account, 1. paste the response code back to the command line. Then you just gained yourself another hour of access.\nThus, here comes the second solution, using oauth2.py from gmail-oauth2-tools, and this time, it does return a refresh token, if you use the first mode of operation on the command line.\n oauth2 --user=xxx@gmail.com \\\n    --client_id=1038[...].apps.googleusercontent.com \\\n    --client_secret=VWF[...]OplZ \\\n    --generate_oauth2_token\nso after hit Enter, you would get back a url to paste into a browser, then hit Enter again, you would need to login and authorize the API to access your account, and after that, it will return a url, pasting that returned url back into the terminal completes the process.\nNow, in the terminal, standard input and standard output of getting access token and refresh token should look somewhat like this\n$ ./oauth2.py --user=your.gmail --client_id=your.client.id --client_secret=your.client.secret --generate_oauth2_token\nTo authorize token, visit this url and follow the directions:\n  https://accounts.google.com/long.foo.bar.url.string\nEnter verification code: code.you.get.back\nRefresh Token: your.refresh.token.is.here \nAccess Token: your.access.token.is.here \nAccess Token Expiration Seconds: 3599\nAfter you get that refresh token, you are basically done! What you need next is the following lines in your ~/.mutt/muttrc config file (or whichever location you put your muttrc file)\nset editor = \"vim\"\nset charset = \"utf-8\"\nset record = ''\n\nset imap_authenticators=\"oauthbearer:xoauth2\"\nset imap_oauth_refresh_command=\"/you/path/to/oauth2.py --quiet \\\n    --user=xxx@gmail.com \\\n    --client_id=1038[...].apps.googleusercontent.com \\\n    --client_secret=VWF[...]OplZ \\\n    --refresh_token=1/Yzm6M[...]oyTum4YA\"\n\nset smtp_authenticators=${imap_authenticators}\nset smtp_oauth_refresh_command=${imap_oauth_refresh_command}\nThen with some additional config that look more or less like the following, you will have a completely functional email client right in your terminal!\nset from = \"your@gmail.com\"\nset realname = \"your name\"\n\n# Imap settings\nset imap_user = \"your@gmail.com\"\n# set imap_pass = \"&lt;mutt-app-specific-password&gt;\" # do not need this since we have oauth 2\n\n# Smtp settings\nset smtp_url = \"smtps://your@smtp.gmail.com\"\n# set smtp_pass = \"&lt;mutt-app-specific-password&gt;\" # do not need this\n\n# Remote gmail folders\nset folder = \"imaps://imap.gmail.com/\"\nset spoolfile = \"+INBOX\"\nset postponed = \"+[Gmail]/Drafts\"\nset record = \"+[Gmail]/Sent Mail\"\nset trash = \"+[Gmail]/Trash\"\nJust remember to replace lines with your to your actual email address and so on.\nThe next time you want to access email, just type mutt on the command line and hit Enter, and everything will work! (Hopefully!)"
  },
  {
    "objectID": "projects/project-04/main.html",
    "href": "projects/project-04/main.html",
    "title": "Project-04 neovim config",
    "section": "",
    "text": "Project-04 neovim config\nI have been using neovim for a while now, and yes, the initial upfront time investment in learning vim is definitely worthwhile. I have kept my neovim config in this repository, and it is not very original, since it is basically put together from chunks and snippets of code here and there on the internet, and adding a little bit of tweak to suit some personal idiosyncrasies. Nevertheless, it has everything I need for now. I use parker.nvim to manage my plugins, but I might switch to lazy.nvim in the near future. While writing this post, I could hit Alt + k to open markdownpreview in an existing browser session, which is equivalent to type the command :MarkdownPreview. And this is achieved by installing the following plugin via packer\n-- install without yarn or npm\nuse({\n    \"iamcco/markdown-preview.nvim\",\n    run = function() vim.fn[\"mkdp#util#install\"]() end,\n})\n\nuse({ \"iamcco/markdown-preview.nvim\", run = \"cd app && npm install\", setup = function() vim.g.mkdp_filetypes = { \"markdown\" } end, ft = { \"markdown\" }, })\nAnd other plugins are installed similarly. There are full-blown IDEs right in your terminals like LunarVim, but right now, I just want to focus on a few things.\n\nnvim and LaTex\nI think the major benefit of writing mathematics using nvim locally versus using Overleaf is you get to use snippets. And there is an excellent guide here. Before I tell you how I use snippets in typesetting math, let us first figure out how to install Tex locally on your machine. For me, I am on a ubuntu machine right now, so I open a browser and go to https://www.tug.org/texlive/quickinstall.html and follow their tl;dr direction: 1. cd into a directory where you want to keep the binary files, 1. download using this command wget https://mirror.ctan.org/systems/texlive/tlnet/install-tl-unx.tar.gz 1. alternatively, using curl to download: curl -L -o install-tl-unx.tar.gz https://mirror.ctan.org/systems/texlive/tlnet/install-tl-unx.tar.gz 1. then simply enter the following command in the terminal and wait for the process to complete:\nzcat &lt; install-tl-unx.tar.gz | tar xf -\ncd install-tl-*\nsudo perl ./install-tl --no-interaction\n\none common error\nOne common error is one might not have perl or curl or (some other necessary packages) installed on one’s linux machine, so we can check via the following command:\ncurl --version\nperl --version\nand if you do not see the version number and some general info in the standard output, then you might not have it installed on your machine. To install, (take ubuntu for example) we can do the following;\nsudo apt update && sudo apt upgrade \nthis step is to update your system’s package repository, so you could get the latest versions. Then we run the following;\nsudo apt install perl\nsudo apt install curl\nand after the installation finishes, we should be good to go. #### another common error Another common error is to forget to add texlive to your PATH. After installing Tex, usually in the terminal standard output, there’s direction to add a string like the following to PATH:\n/usr/local/texlive/2023/bin/x86_64-linux\nI have the following lines in my ~/.bashrc to achieve precisely this:\n# add to PATH texlive\nexport  PATH=\"/usr/local/texlive/2023/bin/x86_64-linux:$PATH\"\nand if you have just added this line to your .bashrc, don’t forget to source it for it to take effect in the existing terminal, otherwise, you need to open a new terminal for it to take effect. One quick way to check if it is already in your PATH:\necho \"$PATH\"\nthen you could just eyeball the output and see if the desired string is already there."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\nI have made this website using quarto, so basically, I write everything in markdown in a main.md file in the projects directory, and after I am finished, I run a terminal command:\nquarto render\nwhile in the directory of this quarto project. The files that I edit to make this website basically have the following directory structure:\n├── index.qmd\n├── projects\n│   ├── project-01\n│   │   └── main.md\n│   ├── project-02\n│   │   └── main.md\n│   ├── project-03\n│   │   └── main.md\n│   └── project-04\n│       └── main.md\n├── _quarto.yml\nand after hitting that magic quarto render, it automatically generates a docs directory that has a lot more stuff in it, and the directory structure looks like this:\n├── docs\n│   ├── about.html\n│   ├── index.html\n│   ├── listings.json\n│   ├── projects\n│   │   ├── project-01\n│   │   │   └── main.html\n│   │   ├── project-02\n│   │   │   └── main.html\n│   │   └── project-03\n│   │       └── main.html\n│   ├── search.json\n│   ├── site_libs\n│   │   ├── bootstrap\n│   │   │   ├── bootstrap-dark.min.css\n│   │   │   ├── bootstrap-icons.css\n│   │   │   ├── bootstrap-icons.woff\n│   │   │   ├── bootstrap.min.css\n│   │   │   └── bootstrap.min.js\n│   │   ├── clipboard\n│   │   │   └── clipboard.min.js\n│   │   ├── quarto-html\n│   │   │   ├── anchor.min.js\n│   │   │   ├── popper.min.js\n│   │   │   ├── quarto.js\n│   │   │   ├── quarto-syntax-highlighting.css\n│   │   │   ├── quarto-syntax-highlighting-dark.css\n│   │   │   ├── tippy.css\n│   │   │   └── tippy.umd.min.js\n│   │   ├── quarto-listing\n│   │   │   ├── list.min.js\n│   │   │   └── quarto-listing.js\n│   │   ├── quarto-nav\n│   │   │   ├── headroom.min.js\n│   │   │   └── quarto-nav.js\n│   │   └── quarto-search\n│   │       ├── autocomplete.umd.js\n│   │       ├── fuse.min.js\n│   │       └── quarto-search.js\n│   └── styles.css\n├── favicon.ico\nand that’s where the magic happens. Then all I need to do is check that deploy from docs box on github, so the github pages will know to get everything it needs for the website from the docs folder."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "my-portfolio-website",
    "section": "",
    "text": "My name is Xianzhi, welcome to my portfolio website! This is a place where I document my coding projects and some relevant (as well as random) tech stuff!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProject-01 My Custom Keymap using Kmonad\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProject-02 Email without leaving the comfort of one’s terminal using Mutt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProject-03 My blog projects\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProject-04 neovim config\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/project-03/main.html",
    "href": "projects/project-03/main.html",
    "title": "Project-03 My blog projects",
    "section": "",
    "text": "Project-03 My blog projects\nI have been writing technical blog posts, feel free to check them out!\nHere’s a link to my Blog for CSCI 0451 class taken during spring 2023: My_Flabbergasted_CSCI_0451_Blog\nHere’s a link to my other blog, which contains some miscellaneous items: A Blog I started that I called My Very Own"
  },
  {
    "objectID": "projects/project-01/main.html",
    "href": "projects/project-01/main.html",
    "title": "Project-01 My Custom Keymap using Kmonad",
    "section": "",
    "text": "Project-01 My Custom Keymap using Kmonad\nLet me tell you about this wonderful keyboard management tool called Kmonad and how I use it (link).\n\nMy kmonad config\nIn my own words, kmonad is a software level (contrast to firmware level) tool that let you to remap your keys however you want. In perticular, it allows you to define different layers, thus allowing the same key to produce different symbols when typed in different layers.\nI have three layers (inspired by the lily58 split keyboard layout, and the Corne keyboard layout found at this website), and they are as follows:\n\nthe default: qwerty layer\nnumbers on the home row: lower layer\nleft down up right at hjkl: raise layer\n\n\n\nspace key has dual functionality with tap versus hold:\nin the qwerty layer:\n\ntap: acts as ordinary space key\nhold: (more than 150 millisecond) toggles into the lower layer\n\nIf we are already in raise layer or lower layer:\n\ntap the space key: acts as ordinary space key\nhold the space key: (more than 150 millisecond) toggles back to the qwerty layer (not sure if this is useful)\n\nIn addition to the toggle functionality, which means one must hold down the toggle key for the layer to remain activated, there is the switch functionality, which means we just need to tap the switch key once, and we are in the desired layer, without needing to hold it down the entire time. Then we can tap a another switch key (usually the same key) to swich back to the layer we started with. In my config, we have the following swich keys:\n\nF1 key switches between qwerty layer and lower layer\nF2 key switches between qwerty layer and raise layer\n\nNote that we don’t usually switch to the lower layer, we would rather just use our thumb to toggle, so upon release the space key, we automatically go back to the qwerty layer.\nI also put the modifier keys on the Home Row. Thus, I might make the left Shift key into a toggle key for raise layer, using the tap versus hold functionality.\n\n\nHome Row Modifiers\nI have put the modifier keys on my Home Row with the following order: - Pinkie: Shift - Ring finger: Ctrl - Middle finger: Alt or sometimes called Meta - Index finger: Super aka Windows key aka OS key\nAgain, this is using the tap versus hold functionality. If I tap the key, then I am typing asdf and jkl; normally. However, if I hold the key, i.e., keep my finger pressed down on the key longer than 150 millisecond before releasing, then I activate the modifier key, and I could tap another key at the same time as one would normally use modifier keys. (for example, Ctrl + T to open a new tab in firefox browser).\n\n\n“Why would I ever want to do this to my keyboard?” you asked.\nwell, the philosophy is we could use the thumb more,\nuse left thumb to hold the space key to toggle into lower layer,\nthen the right hand could easily type\n`!@#$%`\n    `12345`\n        `_-+[{`,\nand upon releasing the space key, we automatically gets back to the qwerty layer.\nWhile use right thumb to hold the space key to toggle into lower layer,\nthen the left hand could easily type\n            `^&*()`\n                `67890`\n                    `}],.=`,\nand upon releasing the space key, we automatically gets back to the qwerty layer.\nHence, holding the space bar using our thumbs acts like Shift, but with different layers and keys."
  }
]